// 29_04_2011
// исходный av11_20.h
// uses driver av11.sys v.1.2 or higher
// добавления в описание для getfilelist(), OpenFileForRead()
//
// av11_20.h
// исправлены ошибки в именах п.п
//int getfilelist() -
//int ReadNextPage()
//добавлено описание для ReadNextPage()
//
// av11_19.h
// изменены комментарии для get_version() в связи с реализацией функции для
// БУИ-11_01 (v.4.10)

// av11_18.h
// изменено описание  OpenFileForRead()
// добавлена константа nandpagesize для БУИ-NAND
// добавлено объявление getdevicepid() - прочитать PID устройства
//

//  av11_17.h
// добавлено объявление:
//
//int GetFileList()              команды
//int OpenFileForRead()          для
//int ReadNextPages()            БУИ-NAND
//
//int getmem() - чтение ОЗУ (контроллера) - параметры изменены!
//int setmem() - чтение ОЗУ (контроллера) -
//
// для работы с БУИ-NAND необходим драйвер AV11.SYS версии не ниже 1.2.1.0
// установки нужен av11_01.inf
//
//
//
// av11_16.h
// исключен код -9 от get_initerror();
//
// av11_15.h
// добавлено объявление:
// - panelenable() - функции, устанавливающей обработчик
// нажатия кнопок на выновном пульте ав-11 с usb-can адаптером
// - get_libver(void) - возвращает номер версии DLL
// - get_initerror()  - возвращает код ошибки при инициализации
// - canidchange() - изменяет CAN-идентификатор устройства
//
//
//
#define pagesize  1056 // размер страницы flash
#define nandpagesize 2112 // размер страницы nand-flash (БУИ-NAND)

#define max_canmsgsize 504 // макс. число байт, которое можно записать в
// в выходной буфер USB-CAN для АКП

//
// Вызываем, после загрузки dll.
// выход: бит 0 установлен, если подключена АКП
//        бит 1 установлен, если подключен БУИ
//        остальные равны 0
//
__declspec (dllimport) int initlib(void);
//-------------------------------------------------------------------
//
// Выполняем при завершении работы.
__declspec (dllimport) void finishlib(void);
//
//-------------------------------------------------------------------
//       ptr - адрес входного буфера
//       amm - число байт для записи

// возвращает 0, если ошибка или не достаточно места для записи;
// или записаное число байт (которое было задано), если запись прошла успешно
//
__declspec (dllimport) USHORT WriteToUSB(UCHAR *ptr, USHORT amm);
//-------------------------------------------------------------------
//
//       ptr - адрес выходного буфера
//       amm - число байт, которые хотим прочитать.
//       any - режим чтения
//
//       Если any=0 и в буфере имеется меньшее число байт, чем amm,то чтение
//       не производится
//       если any != 0, то читаем, сколько есть
//
__declspec (dllimport) UCHAR ReadFromUSB(UCHAR *ptr, UCHAR amm,UCHAR any);
//-------------------------------------------------------------------
//       ptr - адрес выходного буфера
//       amm - число байт для чтенияь. Читаем ровно amm байт, или ничего.
//       Возвращает число прочитанных байт.
//
__declspec (dllimport) UCHAR ReadUSB(UCHAR *ptr, UCHAR amm);
//-------------------------------------------------------------------
//   Включает источник питания, подающий напряжение на линейку
//   В случае БУИ также вызываем эту п.п
//   id -  0 для АКП, 1 - для  БУИ
//
__declspec (dllimport) int power_on(UCHAR id);
//-------------------------------------------------------------------
//   Отключает источник питания.
//   В случае БУИ также вызываем эту п.п
//   id -  0 для АКП, 1 - для  БУИ
__declspec (dllimport) int power_off(UCHAR id);
//-------------------------------------------------------------------
//       id -  0 для АКП, 1 - для  БУИ
// читает quantity страниц памяти, начиная с заданной в относительных
// координатах (страница в пределах м/с (pagenum), номер м/с (chipnum)),
// в буфер пользователя начиная с адреса destbufptr.
//  1 <= quantity <= 62
//  id -  0 для АКП, 1 - для  БУИ
//
//
__declspec (dllimport) int readpages(UCHAR* destbufptr,USHORT pagenum, UCHAR chipnum,UCHAR quantity,UCHAR id);
//-------------------------------------------------------------------
// записывает quantity страниц памяти из буфера пользователя srcbufptr,
// начиная с заданной в относительных координатах (страница в пределах м/с
// (pagenum), номер м/с (chipnum)),
//
//  1 <= quantity <= 62
//  В буфере srcbuptr первые 8 байт не использовать, т.е. данные поместить,
// начиная с байта +8
//  id -  0 для АКП, 1 - для  БУИ
__declspec (dllimport) int writepages(UCHAR* srcbufptr,USHORT pagenum, UCHAR chipnum,UCHAR quantity,UCHAR id);
//-------------------------------------------------------------------
// возвращает число м/с установленных на линейке. Если она не воткнута,
// то должен быть возвращен 0
// id -  0 для АКП, 1 - для  БУИ
//
__declspec (dllimport) int chipcntr(UCHAR id);
//
//-------------------------------------------------------------------
// стирает quantity страниц памяти, начиная с заданной в относительных
// координатах (страница в пределах м/с (pagenum), номер м/с (chipnum)),
//  1 <= quantity <= 62
//
// id -  0 для АКП, 1 - для  БУИ
//
__declspec (dllimport) int erasepages(USHORT pagenum, UCHAR chipnum,UCHAR quantity,UCHAR id);
//-------------------------------------------------------------------
// стирает quantity блоков в пределах м/с, заданной параметром chipnum,
// начиная с блока startblk
//  1 <= quantity <= 1024
//  0 <=chipnum <= (кол-во м/с)-1
//  0 <=startblk <= 1023
//  id -  0 для АКП, 1 - для  БУИ
// возвращает число стертых блоков
//
__declspec (dllimport) int eraseblks(USHORT startblk, UCHAR chipnum,UCHAR quantity,UCHAR id);
//-------------------------------------------------------------------
// только для БУИ
// первые 4 байта srcbufptr оставлять  свободными
// srcbufptr - адрес входного буфера (выделенный объем пока сделать кратным 64)
// srcsize -  размер данных для передачи
// dstbufptr - адрес выходного буфера (возможно, что будет помещено 65536 байт)
//
// выход: 0 -  OK.
//        <0 - код ошибки
//
__declspec (dllimport) int sendinf(UCHAR* srcbufptr,USHORT srcsize, UCHAR* dstbufptr);
//-------------------------------------------------------------------
// только для БУИ
// выход: 0  -  выполнение не завершено
//        >0 -  число байт, помещенных в буфер
//        -12 - прежде не было команды передачи
//        -1  - устройство недоступно
//
__declspec (dllimport) int getstate(void);
//
//-------------------------------------------------------------------
// только для АКП
// Производит включение/отключение блоков через сигнал ON/OFF CAN-разъема
// num = 0 - отключить, остальные значения - включить
// при удачном завершении возвращает значение 1
// отрицательные значения и 0 свидетельствуют об ошибке
//
__declspec (dllimport) int pwrswitch(UCHAR num);
//
//-------------------------------------------------------------------
// только для АКП
// Производит установку переменной flProgrammator в соответствии
// со значением num
// при удачном завершении возвращает значение 1
// отрицательные значения и 0 свидетельствуют об ошибке
//
__declspec (dllimport) int func0(UCHAR num);
//-------------------------------------------------------------------
//
// Получить состояние приемника данных из USB
// 0 - OK
// отрицательные значения соответствуют ситуации, когда прием остановлен
// причина - см значение
//
// вывести в качестве ошибки - модуль результата
//
__declspec (dllimport) int get_rcvstate(void);

//-------------------------------------------------------------------
// Получить состояние передатчика данных в USB
// 0 - OK
// отрицательные значения соответствуют ситуации, когда передача остановлена
// причина - см значение
//
// вывести в качестве ошибки - модуль результата
//
__declspec (dllimport) int get_trstate(void);

//-------------------------------------------------------------------
//-------------------------------------------------------------------
// сравнивает содержимое всех страниц памяти м/схемы chipnum со значением
// sample.
//  id -  0 для АКП, 1 - для  БУИ - не реализовано

// возвращает 0 - заполнение завершено и
// в буфер пользователя dstbuf (16 байт) записываются номера сбойных страниц
// первое слово - число сбойных страниц, далее - номера сбойных страниц
// (нумерация с 0,  число номеров сбойных страниц в буфере - не больше 7)
//        - положительное значение  - заполнение сейчас производится -
// номер сравниваемой страницы + 1
//       - отрицат. значение - код ошибки
// кроме общих
//             код -14  - при заполнении буфера м/сх 1 возникла ошибка
//
//
//             код -15  - после записи в буфер 1 микросхемы не все байты
//  равны sample
//             коды -35, -36 - АКП вернула неверное значение
//
//  чтобы получить корректный результат о завершении процесса
//  не следует вызывать другие п.п работы с картой до завершения вызова
//  этой п.п с нулевым или отрицательным кодом
//
__declspec (dllimport) int pagescmp(UCHAR *dstbuf,UCHAR sample,UCHAR chipnum,UCHAR id);
//-------------------------------------------------------------------

// заполняет все страницы м/схемы chipnum байтом sample
//
//  id -  0 для АКП, 1 - для  БУИ - не реализовано
//
// возвращает 0 - заполнение завершено
//        - положительное значение  - заполнение сейчас производится -
// номер заполняемой страницы + 1
//       - отрицат. значение - код ошибки
// кроме общих
//             код -14  - при заполнении буфера м/сх 1 возникла ошибка
//
//
//             код -15  - после сравнения в буфере 1 микросхемы не все байты
//  равны sample
//             коды -35, -36 - АКП вернула неверное значение
//
//  чтобы получить корректный результат о завершении процесса
//  не следует вызывать другие п.п работы с картой до завершения вызова
//  этой п.п с нулевым или отрицательным кодом
//
__declspec (dllimport) int pagesfill(UCHAR sample, UCHAR chipnum,UCHAR id);
//-------------------------------------------------------------------
// читает идентификатор версии программы в АКП, записанный по:
//  - адресу 0x1DFF8 в памяти программ для АКП
//  - адресу 0x1FBF8 в памяти программ для БУИ v.4.10
// ptr - указатель на буфер пользователя
// id = 0/1 - АКП/БУИ
// в буфер пользователя записывает 8 байт, если возвращает 8
// отрицательное значение - код ошибки
//
__declspec (dllimport) int get_version(UCHAR *ptr, UCHAR id);

//-------------------------------------------------------------------
// возвращает статус м/с
//  id -  0 для АКП, 1 - для  БУИ

__declspec (dllimport) int chipstatus(UCHAR num,UCHAR id);

//-------------------------------------------------------------------

// заполняет все страницы м/схемы chipnum из буфера 1, заполненным
// словами со значениями 0...528
//
//  id -  0 для АКП (v.1.7), 1 - для  БУИ - не реализовано
//
// возвращает 0 - заполнение завершено
//        - положительное значение  - заполнение сейчас производится -
// номер заполняемой страницы + 1
//       - отрицат. значение - код ошибки
// кроме общих
//             код -14  - при заполнении буфера м/сх 1 возникла ошибка
//
//
//             код -15  - после сравнения в буфере 1 микросхемы не все байты
//  равны sample
//             коды -35, -36 - АКП вернула неверное значение
//
//  чтобы получить корректный результат о завершении процесса
//  не следует вызывать другие п.п работы с картой до завершения вызова
//  этой п.п с нулевым или отрицательным кодом
//
__declspec (dllimport) int pagesmfill(UCHAR chipnum,UCHAR id);
//-------------------------------------------------------------------
// сравнивает содержимое всех страниц памяти м/схемы chipnum со значением
// ранее записанным pagesmfill()
//
//  id -  0 для АКП  (v.1.7), 1 - для  БУИ - не реализовано

// возвращает 0 - заполнение завершено и
// в буфер пользователя dstbuf (16 байт) записываются номера сбойных страниц
// первое слово - число сбойных страниц, далее - номера сбойных страниц
// (нумерация с 0,  число номеров сбойных страниц в буфере - не больше 7)
//        - положительное значение  - заполнение сейчас производится -
// номер сравниваемой страницы + 1
//       - отрицат. значение - код ошибки
// кроме общих
//             код -14  - при заполнении буфера м/сх 1 возникла ошибка
//
//
//             код -15  - после записи в буфер 1 микросхемы не все байты
//  равны sample
//             коды -35, -36 - АКП вернула неверное значение
//
//  чтобы получить корректный результат о завершении процесса
//  не следует вызывать другие п.п работы с картой до завершения вызова
//  этой п.п с нулевым или отрицательным кодом
//
__declspec (dllimport) int pagesmcmp(UCHAR *dstbuf,UCHAR chipnum,UCHAR id);
//-------------------------------------------------------------------
typedef void(*pfunc)(UCHAR);
// устанавливает/удаляет обработчик (пользователя) событий по нажатиям кнопок
// на выносном пульте. В качестве параметра обр-к принимает код, где:
// бит 7 -  1-нажата/0-отжата
// биты 1..0 - номер кнопки пульта
//     0 - кнопка "Координата"
//     1 - кнопка "Болтовой стык"
//     2 - кнопка "Сварной стык"
// если funcaddr == NULL, обработчик удаляется.
// при успешном завершении возвращает 0
// коды ошибок, кроме прочих:
// (-37) - повторный вызов функции с ненулевым параметром, когда раннее
// обработчик был уже установлен
//
// обработчик должен быть объявлен как cdecl
//
__declspec (dllimport) int panelenable(pfunc funcaddr);
//-------------------------------------------------------------------
//
// возвращает номер версии DLL
__declspec (dllimport) int get_libver(void);

//-------------------------------------------------------------------
// изменяет значение CAN-идентификатора устройства (только АКП)
__declspec (dllimport) int canidchange(UCHAR canid);

//-------------------------------------------------------------------
// выводит состояние переменной, которая в случае возникновения проблем
// после обнаружения устройства примет отрицательное значение.
//
// id=0 - АКП, id=1 - БУИ
//
//  0 - ошибок не обнаружено
// -1 - запрос IOCTL_DRV_RESET_PIPEIO_CANCEL_QUERY для WriteHandle закончился с ошибкой
// -2 - запрос IOCTL_DRV_RESET_PIPEIO_CANCEL_QUERY для ReadHandle закончился с ошибкой
// -3 - запрос IOCTL_DRV_RESET_PIPEIO_CANCEL_QUERY для AddWHandle закончился с ошибкой
// -4 - запрос IOCTL_DRV_RESET_PIPEIO_CANCEL_QUERY для AddRHandle закончился с ошибкой
// -5 - вызов clrcdrcounter() завершился с ошибкой (только АКП)
// -6 - запрос IOCTL_DRV_DEVICE_PID завершился с ошибкой
// -7 - запрос версии драйвера 45line.sys завершился с ошибкой
// -8 - версия драйвера 45line.sys ниже 1.4 (только АКП)
// -9 - исключен
// -10 - не удалось запустить тред AddReader()
//
__declspec (dllimport) int get_initerror(DWORD id);
//
//-------------------------------------------------------------------
// измеряет напряжение аккумулятора
// неотрицательное значение - напряжение Акк в единицах "0,1 В"
//
__declspec (dllimport) int uakk(void);

//-------------------------------------------------------------------
// читает ОЗУ контроллера в буфер пользователя dstbuf,
// число читаемых байт - amm, начальный адрес - saddr
__declspec (dllimport) int getmem(UCHAR* dstbuf, DWORD saddr,USHORT amm,UCHAR flags,UCHAR id);

//-------------------------------------------------------------------
/*
// заполняет в ОЗУ контроллера байтом sample
// число записываемых байт - amm, начальный адрес - saddr
__declspec (dllimport) int setmem(DWORD saddr,USHORT amm,UCHAR sample,UCHAR flags,UCHAR id);
*/
//-------------------------------------------------------------------
// получить список файлов (номера первых страниц) в буфер пользователя *dstbuf
// -  0-й элемент (USHORT)  это число элементов списка (USHORT)
// только для БУИ-NAND
// возвращает:
//   - положительное число - число прочитанных байт,т.е. [FileList[0]+1]*2
//   - отрицательное - код ошибки, в т.ч.
//        -35  неверный код ошибки от устройства, либо он не предусмотрен
//        -38, если команда не поддерживается БУИ
//
__declspec (dllimport) int getfilelist(USHORT *dstbuf);
//-------------------------------------------------------------------
// открыть файл для чтения
// numpage - номер первой страницы
// только для БУИ-NAND
// возвращает:
//   - положительное число - размер файла в страницах
//   - отрицательное - код ошибки, в т.ч.
//   -35  неверный код ошибки от устройства, либо он не предусмотрен
//   -38, если команда не поддерживается БУИ
//   -39, длина файла равна 0
//
__declspec (dllimport) int OpenFileForRead(DWORD numpage);
//-------------------------------------------------------------------
// прочитать quantity страниц файла в буфер пользователя *dstbuf
// только для БУИ-NAND
// число страниц - не более 31
// возвращает:
//   - положительное число - число прочитанных байт
//   - отрицательное - код ошибки,  в т.ч.
//   -38  если команда не поддерживается БУИ
//
__declspec (dllimport) int ReadNextPage(UCHAR *dstbuf, UCHAR quantity);
//-------------------------------------------------------------------
// получить PID устройства
// id = 0 - АКП, id = 1 - БУИ
//  АКП: PID = 0x1
//  БУИ: PID = 0x3
//  БУИ-NANDFLASH: PID = 0xB
//
__declspec (dllimport) int getdevicepid(UCHAR id);
